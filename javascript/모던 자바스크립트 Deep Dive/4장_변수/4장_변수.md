![메인사진](../images/%EB%AA%A8%EB%8D%98%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8_%EB%A9%94%EC%9D%B8%EC%82%AC%EC%A7%84.png)

## 04장 변수

### 4.1 변수란 무엇인가? 왜 필요한가?

- 애플리케이션은 데이터를 다룬다. 아무리 복잡한 애플리케이션이라 해도 데이터를 입력(input)받아 처리하고, 그 결과를 출력(output)하는 것이 전부다.

- 컴퓨터는 CPU를 사용해 연산하고, 메모리를 사용해 데이터를 기억한다.

- 메모리는 데이터를 저장할 수 있는 메모리 셀(memory cell)의 집합체이다. 메모리 셀 하나의 크기는 1바이트(8비트)이며, 컴퓨터는 메모리 셀의 크기, 즉 1바이트 단위로 데이터를 저장(write)하거나 읽어(read)들인다.

- 각 셀은 고유의 메모리 주소(memory address)를 가진다. 이 메모리 주소는 메모리 공간의 위치를 나타내며, 0부터 시작해서 메모리의 크기만큼 정수로 표현된다. 메모리에 저장되는 모든 값은 2진수로 저장된다.

- 10 + 20이라는 연산을 했을 적에 메모리에 값이 저장되지만, 문제가 있다. 이를 재사용할 수가 없다는 것이다.
  이를 재사용하기 위해서는 메모리 주소에 직접 접근하는 것 외에는 방법이 없다. 하지만 메모리 주소를 통해 값에 직접 접근하는 것은 치명적인 오류를 야기할 수 있기에 자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않는다.

- 만약 자바스크립트가 개발자의 직접적인 메모리 제어를 허용하더라도 문제가 있다. 값이 저장될 메모리 주소는 코드가 실행될 때 메모리의 상황에 따라 임의로 결정되는데, 이는 곧 동일한 컴퓨터에서 동일한 코드가 실행되더라도 실행될때마다 메모리 상황에 따라 메모리 주소가 변경되는 문제가 있다.

- **변수(Variable)는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이다. 값의 위치를 가리키는 상징적인 이름인 것이다.**
  <br />이로인해 개발자는 직접 메모리 주소를 통해 값을 저장하고 참조할 필요가 없이 변수를 통해 안전하게 값에 접근할 수 있다.

- 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름을 **변수 이름(변수명)** 이라 한다. 변수에 저장된 값은 **변수 값**. 변수에 값을 저장하는 행위는 **할당(assignment, 대입, 저장)**, 변수에 저장된 값을 읽어 들이는 것을 **참조(reference)** 라 한다.

### var 키워드

var 키워드는 변수를 생성할때 필요한 키워드이다.

- ES5(ECMAScript5)까지는 var 키워드를 사용하다, ES6(ECMAScript6)가 나오면서 var 키워드의 단점을 보완한 let, const 키워드가 도입됐다. 이는 추후챕터에서 설명하겠다.

var 키워드는 변수 선언과 동시에 초기화가 진행된다.
**초기화(initialization)란 변수가 선언된 이후 최초로 값을 할당하는 것을 뜻한다.** <br />
var 키워드로 선언한 변수는 undefined로 암묵적인 초기화가 자동 수행된다.

- undefined는 자바스크립트에서 제공하는 원시타입의 값(primitive value)이다. 이또한 추후챕터에서 설명하겠다.

```javascript
var score; // 변수 선언
console.log(score); // undefined, 선언과 동시에 undefined로 자동 초기화

var score1; // 변수 선언
var score1 = 80; // 값의 할당
```

만약 변수의 초기화 단계를 거치지 않는다면 확보된 메모리 공간에는 이전에 다른 애플리케이션이 사용했던 값이 남아있을 수 있다. 이러한 값을 **쓰레기 값(garbage value)** 이라고 한다. <br />
변수를 선언하려면 반드시 선언(declaration)이 필요하다. 변수 뿐만이 아닌 모든 식별자(함수, 클래스)가 그렇다. 만약 선언하지 않은 식별자에 접근하면 ReferenceError(참조 에러)가 발생한다.

### 4.4 변수 선언의 실행 시점과 변수 호이스팅

```javascript
console.log(score); // undefined
var score; // 변수 선언문
```

위 예제를 보면 변수 선언문보다 변수를 참조하는 코드가 앞에 있다. 자바스크립트 코드는 인터프리터(interpreter)에 의해 한 줄씩 순차적으로 실행된다. 따라서 참조에러가 발생할거 같지만, undefined가 출력된다.
그 이유는 **변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임(Runtime)이 아니라 그 이전 단계에서 먼저 실행되기 때문이다.** 자바스크립트 엔진은 변수 선언을 포함한 모든 선언문을 먼저 소스코드에서 찾아내 실행한 다음 모든 선언문을 제외하고 순차적으로 소스코드를 실행하는 특성을 지니고 있다.
**이처럼 변수 선언문이 코드의 앞으로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅(variable hoisting)이라 한다.**

### 4.5 값의 할당

**앞서 말했듯 변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 변수 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임때에 실행된다.**
아래의 예제를 참고하자.

```javascript
console.log(score); // undefined

var score; // 1. 변수 선언
score = 80; // 2. 값의 할당

console.log(score); // 80
```

하지만 위처럼 변수 값을 할당할 때에는 문제가 발생한다. 이전 값 undefined가 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 할당 값 80을 덮어서 저장하는 것이 아닌, **새로운 메모리 공간을 확보**하고 그곳에 할당 값 80을 저장한다. 아래 예제를 참고하자.

```javascript
console.log(score); // undefined

score = 80; // 값의 할당
var score; // 변수 선언, 80, 먼저 변수 선언을 실행했기에 런타임때 실행되는 80의 값이 대입됨.

console.log(score); // undefined, 변수 명은 score로 동일하지만 서로 다른 메모리 주소를 가진다.
```

### 4.6 값의 재할당

var 키워드로 선언한 변수는 값을 재할당할 수 있다. 재할당은 현재 변수에 저장된 값을 버리고 새로운 값을 저장한다.
재할당은 변수에 저장된 값을 다른 값으로 변경한다. 그래서 변수라고 일컫는다. **만약 값을 재할당 할수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 상수(constant)라고 한다.**

- ES6에서 추가된 let 키워드는 변수, const 키워드는 상수의 역할을 수행한다.

```javascript
var score = 80; // 변수 선언과 값의 할당
score = 90; // 값의 재할당
```

![값의_재할당](../images/4%EC%9E%A5_%EB%B3%80%EC%88%98_%EA%B0%92%EC%9D%98%EC%9E%AC%ED%95%A0%EB%8B%B9.png)

위 그림처럼 score의 최종 값의 할당은 90이다. 그렇다면 이전에 할당되었던 undefined 값과, 80은 어디로 갔을까? 아무도 사용하고 있지 않은 이런 불필요한 값들은 가비지 콜렉터(garbage collector)에 의해 메모리에서 자동 해제된다.

### 4.7 식별자 네이밍 규칙

식별자(identifier)는 어떤 값을 구별해서 식별해낼 수 있는 고유한 이름이다. 식별자는 다음과 같은 네이밍 규칙을 준수해야 한다.

- 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(\_), 달러기호($)를 포함할 수 있다.
- 단, 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(\_), 달러기호($)로 시작해야 한다. 숫자로 시작하는 것은 허용하지 않는다.
- 예약어는 식별자로 사용할 수 없다.

![자바스크립트_예약어](../images/4%EC%9E%A5_%EB%B3%80%EC%88%98_%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8_%EC%98%88%EC%95%BD%EC%96%B4.png)

다음은 예제들이다.

```javascript
var first-name; // - 일반 대시바는 허용되지 않는다.
var 1st; // 숫자가 식별자 앞에 사용되는 것은 허용되지 않는다.
var this; // this는 예약어이기에 사용이 불가하다.
```

**자바스크립트는 대소문자를 구별한다. 따라서 다음 변수들은 각각 별개의 변수들이다.**

```javascript
var firstname;
var firstName;
var FIRSTNAME;
```

**네이밍 컨벤션(naming convention)은** 하나 이상의 영단어로 구성된 식별자를 만들 때 가독성 좋게 단어를 한눈에 구분하기 위해 규정한 명명 규칙이다.

```javascript
var firstName; // 카멜 케이스(camelCase), 보편적으로 가장 많이 사용한다.

var first_name; // 스네이크 케이스(snake_case)

var FirstName; // 파스칼 케이스(PascalCase)
```

일반적으로 변수나 함수의 이름에는 카멜 케이스를 사용하고, 생성자 함수&클래스의 이름에는 파스칼 케이스를 사용한다.
