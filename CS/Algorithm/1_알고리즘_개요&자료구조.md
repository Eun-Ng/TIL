## 알고리즘(Algorithm) 개요&자료구조

### 알고리즘의 필요성

#### 알고리즘은 왜 필요한가?

![알고리즘은 왜 필요한가](./images/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%80_%EC%99%9C_%ED%95%84%EC%9A%94%ED%95%9C%EA%B0%80.png)

#### 알고리즘은 무엇인가?

![알고리즘은 무엇인가](./images/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%80_%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80.png)

### 자료구조(Data Structure)

![자료구조와 알고리즘의 관계](./images/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98_%EA%B4%80%EA%B3%84.png)

- 자료구조라 함은 컴퓨터 기억공간 내에 자료를 표현하고 조직화하는 방법을 의미한다. 문제에 맞는 적절한 자료구조를 선택해야만 보다 효율적으로 자료를 처리할 수 있다.

- 결국, 좋은 프로그램을 만들려면 자료구조와 알고리즘이 적절히 조화를 이루어야 한다.

#### 배열(Array)과 연결 리스트(Linked List)

#### 배열(Array)

- 배열이란 같은 자료형을 갖는 여러 원소(데이터)를 하나의 변수이름으로 모아 놓은 데이터의 집합이다. 배열은 **인덱스(index), 원소값(value)** 쌍의 집합으로, 하나의 인덱스가 주어지면 이와 연관된 원소값이 결정되는 대응 관계를 갖는다.

- 배열 표현의 가장 큰 특징은 데이터의 논리적 순서와 저장된 물리적 순서가 같다는 것이다.

- 장점

  - 표현이 간단하다.
  - 순서에 따른 순차적 데이터 접근이 아니라 인덱스를 이용하여 빠른 임의 접근이 가능하다.

- 단점

  - 메모리 크기가 정적이다.
  - 데이터 삽입/삭제 과정이 비효율적이다.(데이터들이 순차적으로 저장되기에, 데이터의 삽입과 삭제가 발생하는 경우에 시간적인 오버헤드(Overhead)가 발생한다)

    **오버헤드(Overhead)**: 어떤 처리를 하기 위해 들어가는 간접적인 처리 사간, 메모리 등을 일컬음.

  - 데이터 재정렬 방식이 비효율적이다. (데이터의 논리적 순서와 동일하게 물리적 순서를 유지하기 위해서 데이터가 삽입/삭제가 수행되는 위치 이후에 있는 모든 데이터를 한 자리씩 뒤나 앞으로 이동시켜야 한다)

  - 배열의 크기 대부분은 정적으로 결정되기에 삽입과 삭제가 동적으로 발생하는 상황에서 적절한 배열의 크기를 미리 결정하는 것이 어렵고, 이로 인해 오버플로(Overflow)나 저장공간의 낭비를 초래할 수 있다.

  **오버플로(Overflow)**: 컴퓨터의 정수 연산의 계산 결과가 허용 범위를 초과할 때 발생하는 오류. 메모리가 꽉 차서 발생되는 스택 오버플로(Stack Overflow)도 있다.

![배열](./images/%EB%B0%B0%EC%97%B4.png)

#### 연결 리스트(Linked List)

- 배열의 문제점을 보완한 형태의 자료구조

- 물리적으로는 데이터를 기억장치의 어느 곳에 저장해도 되지만, 기억 장치의 임의 위치에 저장된 데이터 간의 논리적인 순서를 유지하는 것이 필요하다.

- 하나의 데이터를 저장할 때 논리적으로 다음 데이터가 어디에 저장되어 있는지를 함께 나타내야 한다. 이를 위해 데이터 필드와 링크 필드로 이루어진 **노드**라는 저장구조를 이용한다.

- 노드는 참조 시스템으로 작동된다. 데이터를 각 노드에 저장할 때 다음 수선의 자료가 있는 위치를 데이터에 포함시킨다. 이렇게 각 **노드들은 서로 연결되어 있다**.

- 장점

  - 새로운 데이터들의 삽입/삭제가 용이하고 효율적이다.
  - 논리적 순서와 물리적 순서를 반드시 일치시킬 필요 없다.
  - 새로운 데이터 삽입/삭제시 배열처럼 구조의 재구성이 필요없다.
  - 메모리 크기가 동적이다.
  - 대용량 데이터 처리에 적합하다.

- 단점

  - 배열보다 메모리 사용량이 많다.
  - 특정 데이터를 찾는데 비효율적이다.(특정 데이터를 찾기 위해 배열은 인덱스 값만으로 바로 접근이 가능하지만, 연결 리스트는 첫 번째 데이터를 가진 노드부터 시작해 원하는 데이터가 있는 노드까지 모든 노드를 찾아야 한다.)

![연결 리스트](./images/%EC%97%B0%EA%B2%B0_%EB%A6%AC%EC%8A%A4%ED%8A%B8.png)

#### 배열과 연결 리스트의 종류

![배열과 연결 리스트의 종류](./images/%EB%B0%B0%EC%97%B4%EA%B3%BC_%EC%97%B0%EA%B2%B0_%EB%A6%AC%EC%8A%A4%ED%8A%B8%EC%9D%98_%EC%A2%85%EB%A5%98.png)

- 배열은 인덱스 개수에 따라 1차원 배열과 다차원 배열(2차원, 3차원 배열)로 나뉘어진다.

- 단일 연결 리스트

  - 단방향으로 움직인다.
  - 하나의 링크필드를 갖고있다.

- 단일 원형 연결 리스트

  - 단방향으로 움직인다.
  - 하나의 링크필드를 갖고있다.
  - 마지막 노드와 첫번째 노드가 서로 연결되어있어 순회한다.

- 이중 연결 리스트

  - 양방향으로 움직인다.
  - 두개의 링크필드를 갖고 있기에, 선행노드와 후행노드 전부 접근 가능하다.
  - 선행노드에 직접적으로 접근이 가능하다.

- 이중 원형 연결 리스트

  - 양방향으로 움직인다.
  - 두개의 링크필드를 갖고 있기에, 선행노드와 후행노드 전부 접근 가능하다.
  - 선행노드에 직접적으로 접근이 가능하다.
  - 마지막 노드와 첫번째 노드가 서로 연결되어있어 순회한다.

#### 스택(Stack)과 큐(Queue)
